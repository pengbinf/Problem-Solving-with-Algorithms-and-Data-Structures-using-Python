# 导论 #

## 1.1 目标 ##
* 了解计算机科学，编程以及解决问题的思想
* 了解抽象及其在解决问题过程中的作用
* 理解并实现抽象数据类型的概念
* 回顾Python

## 1.2 开始 ##

自从第一台需要使用大量线缆和开关来实现人机交互的电子计算机诞生以来，人们对于编程的看法已经经历了巨大的变化。跟社会中很多领域一样，计算科学的发展使得计算机科学家能够使用越来越多的工具。高速处理器、高速网络以及大容量存储器的不断进步导致了复杂度的螺旋式上升，而计算机科学家必须将其解决。在飞速发展期间，也有许多基本原则经久不变。计算科学本身关注的是利用计算机来解决问题。

毫无疑问，你已经花费了大量时间来学习解决问题的基本知识。希望你也能对自己理解问题并给出解决方案的能力有所信心。你应该也有所了解编写计算机程序常常是具有相当难度的。大型问题的复杂性以及由此带来的对应的解决方法的复杂度，往往会掩盖解决问题所需要的基本思路。

本章记下来的部分将要重点强调两个方面的内容。第一，回顾计算机科学以及算法与数据结构的研究必须要满足的基本框架，尤其是我们为何需要学习这些内容以及这些内容将会如何帮助我们更好地解决问题。第二，回顾Python。尽管无法提供详细全面的指导，本章将给出案例并对接下来的章节中将会出现的概念和思路进行解释。

## 1.3 计算机科学是什么？ ##

一般来说计算机科学很难准确定义。这也许是由于“计算机”这个名字的滥用。也许你已经清楚，计算机科学并不仅仅是对计算机的研究。尽管计算机在该学科中作为工具而起着支撑性作用，然而它也仅仅是 **工具** 而已。

计算机科学是对问题本身、问题的解决、在问题求解过程中得出的解决方案的研究。给定一个问题，以为计算机科学家的目标便是开发一种**算法**，即用来解决该问题可能出现的各种实例的一份详细的指令集清单。算法通过执行有限的过程解决问题。算法便是解决方案。

计算机科学可以被看作是对算法的研究。然而，我们必须考虑到有些问题是无解的。尽管证明此论断超过了本书的范畴，但对于学习计算机科学的人来说，有些问题确实是无解的这一事实是很重要的。通过引入问题的类型，我们便可以完整地定义计算机科学：计算机科学研究的是问题的解决方案以及没有解决方案的问题

谈及问题和解决方案时，**“可计算（*computable*）”**这个词是很常见的。当用于解决某个问题的算法存在时，我们称该问题为可计算的。于是，另一种对计算机科学的定义为：研究问题是否是可计算的或者说研究算法的存在与不存在。在大多数情况下，你会注意到“计算机”这个词并不会出现。算法被认为是独立于机器的。

计算机科学本身属于问题求解过程，因此也是对 **抽象** 的研究。抽象使得我们可以用类似于将所谓的逻辑对象与物理对象区分开来的方式来处理问题及其解决方案。在下文所述的常见案例中的这种思想对我们来说是很熟悉的。

考虑你今天驾驶的去往学校或公司的汽车。作为司机，也就是汽车的使用者，你拥有一系列按一定顺序发生的交互方式来使得汽车能够按照预定意图运行。为了实现驾驶，你需要坐进汽车，插入钥匙，启动汽车，换挡，刹车，加速，转弯。从抽象的观点来考虑，我们说你看到的是汽车的逻辑面。你使用的是由汽车设计者提供的实现将你从某个地方移动至另一个地方的功能。这些功能有时也被称作 **界面** 。

另一方面，汽车修理工有着大不一样的观点。他不仅知道如何驾驶同时也必须知道实现那些我们认为理所当然的功能所必需的所有细节。他需要知道引擎是如何运行的，换挡器如何实现变速，如何控制温度等等。这被认为是物理角度,即发生“在引擎盖下”的细节。

我们使用计算机时也是一样。大多数人使用计算机来书写文档、发送与接受邮件、浏览网页、播放音乐、存储图像以及玩游戏，但他们并不了解使得这些应用运行所需要的细节知识。他们从逻辑或者说用户的角度来看待计算机。计算机科学家、程序员、技术员以及系统管理员则是从截然不同的角度来看待。他们必须知道操作系统运行的细节，网络协议是如何配置的以及如何编写各种代码来控制这些功能。他们必须能够控制用户仅仅认为是理所当然的那些底层细节。

这两个例子的相同点是：抽象内容的用户，有时也称之为客户，只要了解界面如何使用即可，而不需了解其底层细节。界面是我们作为用户时与具体实现内部的底层复杂代码进行交流的一种方式。另一个例子以Python的math模块为例。只要我们引入了该模块，便可以进行类似于下面的计算：

```Python
import math(16)

math.sqrt(16)
```

这是一个 **过程抽象（procedural abstraction）** 。我们没必要知道平方根是怎样被计算的，但我们知道这个函数叫什么以及如何使用它。若是正确地进行了导入，便可相信该函数会为我们提供正确的结果。我们知道有人实现了平方根问题的解决方案，但我们仅仅需要了解如何使用它即可。这有时被称为过程的“黑箱”观点。我们仅简单地描述接口：函数的名称，需要提供些什么（参数），以及会返回什么。细节都被隐藏在内部。

### 1.3.1 什么是编程 ###

 **编程** 是形成算法并且将其编写为计算机可以执行的表达，即编程语言。尽管存在许多编程语言和各式各样的计算机，最重要的第一步还是获得解决方案。没有算法便没有程序。
 
计算机科学不是研究编程的。但编程是计算机科学家工作的重要内容。编程常常是解决方案的表达方式。因此，语言表达及其编写方式都成为了该学科的基础部分。
 
算法以表达某问题实例所需要的数据以及生成预期结果所需要的一系列必要步骤来给出该问题的解决方案。编程语言必须提供符号系统来表达过程和数据。为此，编程语言提供了控制结构和数据类型。
 
控制结构使得算法步骤能够以简介而准确的方式表达出来。算法要求至少可以实现顺序处理、决策选择、迭代的结构。只要该语言提供了这些基本的语句，便可以用于算法表达。

在计算机中，所有的数据都以二进制数字串表示。为了使得这些数字串具有意义，便有了**数据类型**。数据类型为这些二进制数据提供解释，这样我们便能够以对于求解问题有意义的方式来考虑数据。这些底层的、预置的数据类型（有时被称之为原始数据类型）为开发算法提供了基石。

比如说，许多编程语言都提供了“整型”这种数据类型。计算机内存中的二进制数字串被解释为整数并且给予了我们通常赋予整数所具有的意义（如23654和-19）。此外，一种数据类型还提供了数据项所能参与的操作的描述。以整型为例，加减乘这些操作是很常见的。我们会希望数字类型可以参与到这些算数运算中。

我们常常面临的问题是，问题及其解决方案过于复杂。尽管这些简单的、语言内置的结构和数据类型已经足够表达复杂的解决方案，但却不利于我们求解问题的过程。我们需要办法来控制复杂度并且帮助我们开发解决方案。

### 1.3.2 为何要学习数据结构和抽象数据类型？ ###

为了控制程序和问题求解过程的复杂度，计算机科学家利用利用抽象概念使得他们可以专注于“总体框架（big picture）”而无需纠结于细节。通过建立问题域的模型，我们可以使用更好更快的求解过程。这些模型允许我们用根据问题本身，用与之更加匹配的方式，来描述算法所需要操作的数据。

之前，隐藏某个功能的具体底层来使得用户或者客户能够在很高的层次来使用的过程被我们称作过程抽象。现在介绍一种与之类似的概念：**数据抽象**。一个**抽象数据类型**，有时被称作ADT，在不涉及具体实现的情况下，对我们如何看待数据以及许可操作进行了描述。也就是说，我们仅关心该数据表达了什么而不是它最终是如何构造的。有了这种抽象，我们便实现了对数据的封装（encapsulate）。这种理念即是，通过将实现的细节进行封装，使得用户无法接触到它们。这被称为 **信息隐藏（information hiding）** 。

图1.2展示了抽象数据的定义以及它是如何运行的。用户与界面进行交互，执行被抽象数据定义了的操作。抽象数据类型便是与用户进行交互的外壳。具体的实现被隐藏在底层。用户不关注实现的细节。

抽象数据类型的实现，常常被称为 **数据结构（data structure）** 。它需要我们利用编程结构和原始数据类型来构造数据的物理面（physical view）。如前文所述，这两种思考面的分离使得我们可以在不给出如何真正地构造模型的情况下，定义问题所需的复杂模型。这即为数据的 **实现独立（implementation-independent）** 思想。因为存在多种方式去实现某个抽象数据类型，因此实现独立使得程序员可以在不改变用户与数据的交互方式的情况下修改具体实现的细节。使用者可以继续关注于问题求解过程。

### 1.3.3 为何要学习算法？ ###

计算机科学家通过经验不断学习。以观摩他人解决问题或者亲自解决问题的方式来学习。接触不同的问题解决技术并且研究不同的算法设计可以帮助我们应对接下来的挑战。通过研究大量不同的算法,我们可以形成模式识别机制，这样下次遇到相似问题时，便可以更好地予以解决。

算法之间往往差异很大。以前文所举的 sqrt 为例，完全有可能存在许多不同的方式来实现计算平方根的函数。某一个算法也许会比其它算法占用更少的资源。而某一个算法也可能需要花费其它算法10倍的实际来返回相同的结果。我们希望找到某种机制来对比不同的算法。即使它们都能运行，也会有某个最优算法。也许会从更简洁的角度来考虑，也有可能从运行更快或是消耗更少内存的角度来考量。在研究算法时，我们可以学会通过对比不同解决方案本身的特点而不是程序或者计算机实现它们的特点。

在糟糕的情况下,我们可能会遇到非常棘手的问题，也就是说没有算法可以在要求的时间内解决问题。将有解问题、无解问题、有解但耗时过高或消耗资源过大的问题区分开来是非常重要的。

论证和取舍算法往往会带来取舍问题。作为计算机科学家，除了解决问题的能力外，也需要掌握问题解决方案评估的技能。最后，一个问题往往有多种解法。寻找解决方案并研究其是否优秀是我们需要不断重复的任务。

## 1.4 Python基础知识回顾 ##

在本节，我们将学习Python编程语言，并给出前文一些思想的具体案例。如果你刚刚接触Python或者说你需要更多的相关信息，我们建议你查询“Python Language Reference”， “Python Tutorial”等资料。在这里，我们的目的是让你重新熟悉该语言并强化对后续章节的一些核心概念的认识。

Python是一种现代，易学，面向对象的编程语言。它拥有一系列强大的内置数据类型和易操作的控制结构。因为Python是一种解释型语言，所以可以通过查看并理解交互式会话便可以实现复查。你应该记得解释器会显示你熟悉的“>>>”提示并检查你给出的Python结构。比如：
```Python
>>> print("Algorithms and Data Structures") 
```
以上代码会显示提示符，print函数，结果，以及下一个提示符。

### 1.4.1 从数据开始 ###

我们说过，Python支持面向对象编程模式。这意味着Python把数据当作问题求解过程的重点。在Python中，跟其它面向对象编程语言一样，我们定义类来描述数据的外观（状态）以及其功能（行为）。类可类比于抽象数据类型，因为类的用户仅能接触到数据项的状态和行为。数据项在面向对象设计中被称为对象。对象是类的一个实例。

#### 内置基本数据类型 ####

现在开始讲述Python的基本数据类型。Python内置了两种与数值相关的类，实现了整型和浮点型数据类型，即 *int* 和 *float* 。标准的算术运算（加减乘除及幂）可以通过使用括号来改变执行顺序。其它很有用的运算有求余运算 **%** 和地板除 **//** 。注意两个整数相除，其结果应当是浮点数。然而除法运算符仅会返回商的整数部分，去掉小数部分。

布尔数据类型，通过Python中的 **bool** 类来实现，对于表达真值非常有用。布尔对象的状态值仅有 **True** 和 **False** ，其标准运算符为 **and, or, not** 。

布尔数据类型也用于比较运算符比如说等于（==）和大于（>）得出的结果。此外，关系运算符和逻辑运算符可以组合起来形成复杂的逻辑问题。

标识符在编程语言中起到名称的作用。在Python中，标识符以字母或者一个下划线（_）开头，对大小写敏感，并且可以是任意长度。请注意，使用具有实际意义的名称可以使得代码更容易阅读与理解。

当一个名称第一次被用在赋值语句的左边时，一个Python变量便产生了。赋值语句提供了一种将名称与值关联起来的方法。变量将会保存数据的引用而不是数据本身。参考下面的例子：

```Python
>>>the_sum = 0
>>>the_sum
0
>>>the_sum = the_sum + 1
>>>the_sum
1
>>>the_sum = True
>>>the_sum
True
```
赋值语句 **the_sum = 0** 创造了一个被称为the_sum的**变量**，并且该变量持有数据对象0的引用。一般来说，赋值语句的右边会进行运算，其结果数据对象的引用将被指派给左边的变量名。在本例中，该变量的类型是整型，因为“the sum”指向的数据类型便是整型。如果该数据的类型发生变化，如上所示变为布尔值True，变量的类型也会发生相应变化。赋值语句更改了该变量所持的引用。这便是Python的动态特性。同一个变量可以指向不同的数据类型。

#### 内置容器数据类型 ####

除了数值和布尔类之外，Python也提供了很多强大的内置容器类。列表，字符串，元组都是在结构上非常相似的有序容器，但它们之间也有些差异需要掌握以正确使用。集合和字典则是无序容器。

列表是包含零或多个指向Python数据类型的有序容器。列表由方括号围起来的、逗号分割的值构成。空列表即[]。列表是非均质性的，也就是说其中的数据对象不必属于同一类，并且列表本身可以赋给变量。下面的代码块演示了列表中数据类型的多样性。

```Python
>>>my_list = [1, 3, True, 6.5]
```
请注意，直接向Python中输入列表的话，列表本身将被返回。然而，为了接下来的操作，其引用应该被赋给某个变量。

因为列表是有序的，因此它支持一系列可用于Python序列类的运算符。

注意到列表的切片是从0开始的。切片操作my_list[1:3]，返回的是列表中以索引为1的项开始到索引为3的项形成的另一个列表（不包含索引为3的那一项）。

有时，我们需要初始化一个列表。这可以利用重复运算迅速完成。
```Python
>>>my_list = [0] * 6
```
与重复运算符相关的非常重要的一点是，其结果是序列中各数据对象的用地址的重复。下面的代码可以很好地解释：
```Python
my_list = [1, 2, 3, 4]
A = [my_list] * 3
my_list[2] = 45
print(A)
```
变量A持有3分对原列表my_list的引用。注意到my_list中一个元素的变化将会在A中的所有3个引用得到体现。

列表支持大量可用于构造数据结构的方法。

有一些方法，比如说pop，不仅返回值并且也会对列表本身进行修改。其它的一些方法，仅是对列表进行修改而不返回值。pop默认抹除最后一项，也可以对溢出并返回指定的某一项。在使用这些方法时，索引范围同样是从0开始的。你应该也注意到了熟悉的“.”符号，它用来让某个对象调用某个方法。my_list.append(False) 可以读作“让对象my_list执行它的append方法并且向其传递一个值False。即使是简单的数据对象比如说整型也可以这样调用方法。
```Python
>>>(54).__add__(21)
75
```
在上述代码中，整型对象54执行了它的add方法（在Python中叫__add__），并且传递了值21用来相加。结果是75.当然，我们一般都写作54 + 21。在本节的后文将进一步讨论这些方法，

range函数是经常与list一起讨论的Python函数。range函数生成表示一系列值的range对象。利用list函数，可以将range对象的值转为列表。如下所示。
```Python
>>>range(10)
range(0, 10)
>>>list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
range对象代表了一组有序整数。默认情况下，它会从0开始。如果你提供了更多参数，它可以从指定位置开始、结束，甚至可以跳过某些项。在我们的第一个例子range(10)中