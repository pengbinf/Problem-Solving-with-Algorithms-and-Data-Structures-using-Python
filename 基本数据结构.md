# 3 基本数据结构 #

## 3.1 目标 ##

- 理解抽象数据结构：栈stack、队列queue、双端队列deque、列表list。
- 利用Python的列表实现抽象数据类型(ADTs) stack、queue、deque。
- 了解各种基本线性数据结构的实现的性能。
- 理解前缀，中缀和后缀表达式。
- 利用stack对后缀表达式进行求值。
- 利用stack将表达式从中缀转换为后缀。
- 利用queue进行基本的时间模拟。
- 能够识别问题的特性，并依次选用stack、queue或者deque中的合适的数据结构。
- 能够实现使用node和reference模式将抽象数据类型实现为链表。
- 能够对比链表与Python实现的列表的性能。

## 3.2 何为线性结构 ##

在开始数据结构的学习前，首先考虑四个简单但很强大的概念：stack、queue、deque、list，它们都是基于添加或者删除方式来定序的数据容器。一旦添加某个项目，它的位置便定于前一个加入的元素和后来将要加入的元素之间。这种数据容器常常被称为线性数据结构。

线性结构可以认为是有两个端。有时被称为“左”和“右”或者“前”和“后”再或者“顶”和“底”。名称并不重要。线性结构与其它数据结构的区别在于元素添加或者删除的方式，尤其是添加和删除的位置。比如说，有些数据结构只允许新元素被添加在某一端；有的结构允许从两端添加。

这种区别形成了计算机科学中一些最有用的数据结构。它们会出现在很多算法里面并用来解决一系列重要问题。

## 何为栈Stack ##

栈（有时称为叠加栈），是一种有序数据容器，其添加或者删除仅发生在同一端。这一端一般称之为“顶”，而另一端就被成为“底”。

栈的底有着重要意义，因为栈中越接近底的元素，说明其在战中储存得最久。最新添加的元素也是最先被移除的元素。这种定序法有时也被称为LIFO(last-in first-out，后进先出法），即根据在容器中停留的顺序来决定顺序。越新的元素越接近顶部，而越旧的项越接近底部。

日常生活中有很多栈的例子。几乎每个咖啡馆都有一堆餐盘，取出了顶部的一个盘子后，餐盘堆中将暴露一个新的餐盘用于提供给接下来的顾客。想象书桌上的一堆书（图1），只有顶部的那本书的封面是可见的。为了获取堆中的其它元素，必须将顶部的移除。图2演示了另一个栈，它包含一些Python的基本数据结构。

![../_images/bookstack2.png](http://interactivepython.org/courselib/static/pythonds/_images/bookstack2.png)
![../_images/primitive.png](http://interactivepython.org/courselib/static/pythonds/_images/primitive.png)

简单观察下栈中元素的添加和删除，便可发现栈最有用的一个思想之一。假设起始桌上有什么都没有。现在开始把书一本一本地放在顶部。这便是在构建一个栈。当移除项的时候，其顺序恰好与放置顺序相反。栈是非常重要的，因为它们可以用来反转元素的顺序。插入顺序和取出顺序相反。图3演示了Python数据对象栈的生成和元素的取出。注意对象的顺序。

![../_images/simplereversal.png](http://interactivepython.org/courselib/static/pythonds/_images/simplereversal.png)

考虑下这种逆转特性，也许在使用电脑时是经常出现的。比如说，网页浏览器都有返回按钮。当从一个网页导航至另一个网页时，这些网页都被存放在栈中（实际上是将URL放入栈中）。当前浏览的页面被放在栈顶，而最先浏览过的那个网页被放于底部。当点击返回按钮时，便会以相反的顺序浏览网页。

## 3.4 栈的抽象数据类型 ##

栈的抽象数据类型通过下列结构和操作定义。如前所述，栈是结构化的，是一种有序元素的集合，它从被称为“顶”的一端进行元素的添加和删除。栈以后进先出法进行定序。栈的操作如下：

- Stack()创建一个新的空栈。它不需要参数，返回一个空栈。
- push(item)将新的元素加入栈的顶部。它需要元素作为参数，无返回结果。
- pop()将顶部的元素取出。它不需要参数，返回结果为被取出的元素。栈本身发生了变化。
- peek()返回栈顶的元素，但并不将其取出。不需要参数，并且不对栈进行修改。
- isEmpty()检测栈是否为空。它不需要参数，并且返回一个布尔值。
- size()返回栈中元素的数量。它不需要参数，并且返回一个整数。

比如说，如果**s**是已存在的空栈，表1展示了一些栈操作的结果。以列表的形式，将栈顶的元素展示在右侧。

| **Stack Operation** | **Stack Contents** | **Return Value** |
| --- | --- | --- |
| `s.isEmpty()` | `[]` | `True` |
| `s.push(4)` | `[4]` |   |
| `s.push('dog')` | `[4,'dog']` |   |
| `s.peek()` | `[4,'dog']` | `'dog'` |
| `s.push(True)` | `[4,'dog',True]` |   |
| `s.size()` | `[4,'dog',True]` | `3` |
| `s.isEmpty()` | `[4,'dog',True]` | `False` |
| `s.push(8.4)` | `[4,'dog',True,8.4]` |   |
| `s.pop()` | `[4,'dog',True]` | `8.4` |
| `s.pop()` | `[4,'dog']` | `True` |
| `s.size()` | `[4,'dog']` | `2` |


## 3.5 在Python中实现栈 ##

既然已经明确将栈定义为一种抽象数据类型，那么现在就来使用Python实现栈。读者应该还记得的，给某个抽象数据类型以物理实现时，这种实现就是数据结构。

如第一章所述，在面向对象语言Python中，实现栈这种抽象数据类型的选择便是新建类。栈的操作以方法的形式实现。此外，为了实现作为元素容器的栈，充分利用Python本身提供的基本容器的强大和简单是非常有意义的。这里使用列表。

Python中的列表类提供了有序容器的机制和一系列方法。比如说，对于列表[2,5,3,6,7,4]，仅需要决定哪一端是作为栈的顶部。一旦确定，便可以使用列表的方法比如说append和pop来实现操作运算。

下面的栈的实现（可执行代码1）假设列表的一端会储存栈顶部的元素。当栈的规模变大时（即使用了push操作），新的元素会被添加在列表的顶部。pop操作也在同一侧进行。

**可执行代码1 使用Python中的列表实现栈**
```python
class Stack:
     def __init__(self):
         self.items = []

     def isEmpty(self):
         return self.items == []

     def push(self, item):
         self.items.append(item)

     def pop(self):
         return self.items.pop()

     def peek(self):
         return self.items[len(self.items)-1]

     def size(self):
         return len(self.items)
```
执行上述代码除了对类的定义外，什么也不会发生。必须要新建一个**Stack**对象并且使用它。可执行代码2按照表1中的操作演示了**Stack**类的使用。注意，**Stack**类的定义是从本书提供的pythonds模块导入的。

**可执行代码2：stack_ex_1**
```Python
from pythonds.basic.stack import Stack

s=Stack()

print(s.isEmpty())
s.push(4)
s.push('dog')
print(s.peek())
s.push(True)
print(s.size())
print(s.isEmpty())
s.push(8.4)
print(s.pop())
print(s.pop())
print(s.size())
```
很重要的一点是，也可以选择列表的开头作为栈的顶部。这样一来，之前的pop和append方法便失效了，必须要索引到位置0（列表的第一个元素），然后显式地使用pop和insert。实现如下：

```Python
| 1 |class Stack: 
| 2 |      def __init__(self): 
| 3 |          self.items = [] 
| 4 |  
| 5 |      def isEmpty(self): 
| 6 |          return self.items == [] 
| 7 |  
| 8 |      def push(self, item): 
| 9 |          self.items.insert(0,item) 
| 10 |  
| 11 |      def pop(self): 
| 12 |          return self.items.pop(0) 
| 13 |  
| 14 |      def peek(self): 
| 15 |          return self.items[0] 
| 16 |  
| 17 |      def size(self): 
| 18 |          return len(self.items) 
| 19 |  
| 20 | s = Stack() 
| 21 | s.push('hello') 
| 22 | s.push('true') 
| 23 | print(s.pop()) 
```
修改抽象数据类型的物理实现同时保持其逻辑特征，这是一种实用抽象的典例。然而，虽然栈在另一种实现下也可以运行，但是考虑下这两种实现的性能，其实是天差地别的。还记得append和pop()操作都是O(1)。也就是说第一种实现无论栈中有多少元素，这两种操作的耗时都是一样的。而第二种实现由于insert(0)和pop(0)的存在，所以其复杂度是O(n)。显然，虽然这两种实现在逻辑上是等效的，但是性能差距是非常大的。

## 3.6 配平括号表达式 ##

现在使用栈来解决一些实际的计算机科学问题。毫无疑问读者曾写过类似的表达式：
(5+6)∗(7+8)/(4+3)
其中括号用于调整操作的顺序。也许读者有使用Lisp等编程语言的经验，并且有类似下面的构建：
```
(defun square(n)
     (* n n))
```
这定义了名为**square**的函数，返回其参数**n**的平方。Lisp被诟病使用了太多太多的括号。

在这些例子中，括号必须以成对的方式实现。**成对括号**意味着，每个开括号必须有一个对应的闭括号与之成对，并且每组括号以正确的方式嵌套。考虑以下括号：
```
(()()()())

(((())))

(()((())()))
```
下面是一些并不成对的：
```
((((((())

()))

(()()(()
```
识别成对或不成对括号，对于正确识别许多编程语言结构是很重要的。

问题便是，给出一种算法从左到右依次读取括号字符串，并确定它是否是平衡的。为了解决该问题需要先来仔细观察一下。从左至右处理符号时，最近的开括号必须与下一个闭括号搭配（如图4）并且，第一个开括号有可能必须要等到最后一个闭括号才能与其形成搭配。闭括号与开括号以它们出现的顺序的逆序进行匹配，它们由外向内匹配。这便给予提示，该问题可以用栈解决。

![../_images/simpleparcheck.png](http://interactivepython.org/courselib/static/pythonds/_images/simpleparcheck.png)

确定了栈是保存括号的合理数据结构后，该算法的语句便很直接了。如果是开括号，将其放在栈顶，表示它需要之后出现一个闭括号与之匹配。如果是闭括号，取出栈顶的首项。只要每一个闭括号都可以在栈顶取出开括号来与之对应，括号表达式便是平衡的。如果栈内没有开括号来与闭括号与之对应了，该表达式就是部平衡的。在最后，所有的括号都被处理完毕，栈必须是空的，否则也是部平衡的。Python实现代码如下可执行代码1所示：

```Python
from pythonds.basic.stack import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index < len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol == "(":
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                s.pop()

        index = index + 1

    if balanced and s.isEmpty():
        return True
    else:
        return False

print(parChecker('((()))'))
print(parChecker('(()'))

```
该函数**parChecker**，以**Stack**类是可用的为基本条件，返回一个布尔值标识该括号字符串是否平衡。注意到布尔变量**balanced**被初始化为True，因为没有理由在开始给以这样的设定。

## 3.7 配平符号 （一般情况） ##

前文描述的配平括号问题是许多编程语言中一种更一般情况的特例之一。配平和嵌套不同的开/闭符号是经常出现的一个问题。比如说，在Python中，方括号[和]被用于列表；花括号{和}被用于字典；圆括号(和)用于元组和运算表达式。在保证每组开/闭符号都配平的前提下，可以将它们组合起来。如下的符号字符串：

```
{ { ( [ ] [ ] ) } ( ) }

[ [ { { ( ( ) ) } } ] ]

[ ] [ ] [ ] ( ) { }
```
必须保证不仅每个开符号有对应的闭符号，还必须保证不同类型的符号正确地搭配了。
比如说下面这些就是没有配平的：

```
( [ ) ]

( ( ( ) ] ) )

[ { ( ) ]
```
前一节给出的圆括号配对检测器可以很容易地拓展，来处理这些新的符号类型。回忆下，每一个开符号都被直接放入栈中等待闭符号与之配对。当闭符号出现时，唯一的区别是在现在这种情况下必须要保证栈顶的符号类型与之匹配。如果这两个类型并不匹配，那该表达式是没有配平的。并且，如果整个表达式都被处理完了，栈此时为空，则该表达式是配平的。

Python实现如可执行代码1所示。唯一的区别是，该函数调用了一个协助函数**matches**，用来完成符号配对。每一个从栈顶移除的符号必须与当前的闭符号进行配对。如果有不配对的情况出现，布尔变量便为设置为False。

**可执行代码1：求解一般配平符号问题**
```Python
from pythonds.basic.stack import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index < len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol in "([{":
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                top = s.pop()
                if not matches(top,symbol):
                       balanced = False
        index = index + 1
    if balanced and s.isEmpty():
        return True
    else:
        return False

def matches(open,close):
    opens = "([{"
    closers = ")]}"
    return opens.index(open) == closers.index(close)


print(parChecker('{{([][])}()}'))
print(parChecker('[{()]'))
```
这两个例子演示了栈在处理计算机科学中的语言构建问题时，是非常重要的数据结构。几乎所有的表达式都有一些必须配平的嵌套符号。计算机科学中，栈还有其它非常重要的用途。接下来几节将继续说明。

## 3.8 十进制转二进制 ##

在计算科学的学习中，读者应当已经或多或少接触到了二进制数字。二进制表示在计算机科学中是很重要的，因为所有计算机中存储的值都是以二进制数字字符串的形式存在的，即由1和0组成的字符串。如果没有在十进制和二进制进行转换，与计算机的交互是相当麻烦的。

整数是很常用的数据元素，计算机程序和计算中都会使用到。大家都是从数学课上接触到整数，当然也都是用十进制表示它们。实际上十进制数$233_10$和其对应二进制等效写法$11101001_2$分别被解释为：
$$
2*10^2+3*10^1+3*10^0
$$
以及
$$
1*2^7+1*2^6+1*2^5+0*2^4+1*2^3+0*2^2+0*2^1+1*2^0
$$
但是如何轻松地将整数转化为十进制数字呢？答案是利用一种被称为“以2相除”的办法，它使用栈来跟踪二进制结果的各个数字。

以2相除的算法首先假设整数是大于0的。接下来，使用一个简单的迭代将该整数除以2，并且跟踪余数。第一次被2相除，确定该值为整数或者奇数。偶数的话，则余数为0，那么在第一个位置，其数位为0。奇数余数为1，并且在第一个位置数位为1。可以将构将二进制数字视为数位序列。计算得到的第一个余数正是该序列的最后一个数位。如图5所示，可以发现逆序性使得栈似乎是解决该问题的合理数据结构。

![../_images/dectobin.png](http://interactivepython.org/courselib/static/pythonds/_images/dectobin.png)


可执行代码1中的Python源码实现了算法以2相除。函数**divideBy2**接受1个十进制数字作为参数，重复地以2相除。代码中使用了内置模块的操作符，%，用来获得余数。在11-13行，当最终被除数变为0时，便构建了一个二进制字符串。11行构建了一个空字符串。栈中的二进制数位被依次取出，然后append到字符串的右端。然后返回该二进制字符串。

**可执行代码1：十进制转二进制**
```Python
from pythonds.basic.stack import Stack

def divideBy2(decNumber):
    remstack = Stack()

    while decNumber > 0:
        rem = decNumber % 2
        remstack.push(rem)
        decNumber = decNumber // 2

    binString = ""
    while not remstack.isEmpty():
        binString = binString + str(remstack.pop())

    return binString

print(divideBy2(42))

```

二进制转换的算法可以轻松拓展使其可用于任何进制的转换。在计算机科学中，使用不同的编码是很常见的。最常见的是二进制，八进制以及十六进制。

整数233对应的八进制和十六进制分别为：$351_8$和$E9_16$，并且分别可以表示为：
$$3*8^2+5*8^1+1*8^0$$
和
$$14*16^1+9*16^0$$
函数devideBy2可以调整为不仅接受十进制，也接受一个转换的进制。那么“以2相除”可以直接用更一般的“以进制相除”。新函数**baseConverter**，如可执行代码2中所示，接受一个十进制数以及任何介于2-16的进制作为参数。余数依然是被放入栈中，直到被转换的值变为0。同样的从左到右字符串构建法稍微调整下便可使用了。二进制到十进制之间需要最大10个数位，即典型的0，1，2，3，4，5，6，7，8，9效果很不错。但是超过十的时候，问题就来了。这时便不可以直接使用余数了，因为它们本身就是用十进制二位数字标识的。作为取代，构建一组数位用于表示超过9的余数。

**可执行代码2：十进制向任意进制转化**
```Python
from pythonds.basic.stack import Stack

def baseConverter(decNumber,base):
    digits = "0123456789ABCDEF"

    remstack = Stack()

    while decNumber > 0:
        rem = decNumber % base
        remstack.push(rem)
        decNumber = decNumber // base

    newString = ""
    while not remstack.isEmpty():
        newString = newString + digits[remstack.pop()]

    return newString

print(baseConverter(25,2))
print(baseConverter(25,16))


```
该问题的一种解决方案就是用字母来扩充数位组。

# 3.9 中缀、前缀和后缀表达式 #

在写出算术表达式如B*C时，表达式的形式提供了信息使得其可以被正确地解释。在此例中，变量B被变量C乘，因为它们之间有一个操作符*。这种写法被称为**中缀**，因为操作符位于两个操作对象之**中**。

考虑另一个中缀的例子，A+B*C。操作符+和*依然在操作对象之间，但有个问题，操作符对哪个操作对象起作用。+是在A和B上起作用，还是说\*对B和C起作用。这个表达式看起来有点模糊不清。

实际上，读者都阅读并书写了大量这些表达式，并不会受到任何困扰。之所以这样是因为读者是了解操作符+和*的。每个操作符都有**优先**级。高优先级的操作符在低优先级的操作符之前先完成运算。唯一可以改变这种优先顺序的是括号。乘法的优先级是高于加和减的。对于相同等级的操作符，那么就使用从左至右的顺序或者说结合律。

对于读者来说这太明显不过了，但是对计算机来说，它必须精准地知道执行操作的顺序。

以下例子是等效的。分别以中缀、前缀、后缀表达式写出。


| **Infix Expression** | **Prefix Expression** | **Postfix Expression** |
| --- | --- | --- |
| A + B | + A B | A B + |
| A + B * C | + A * B C | A B C * + |

| **Infix Expression** | **Prefix Expression** | **Postfix Expression** |
| --- | --- | --- |
| A + B * C + D | + + A * B C D | A B C * + D + |
| (A + B) * (C + D) | * + A B + C D | A B + C D + * |
| A * B + C * D | + * A B * C D | A B * C D * + |
| A + B + C + D | + + + A B C D | A B + C + D + |

### 3.9.1 中缀表达式转换为前后缀表达式 ###


本书使用ad hoc方法实现中缀表达式与其等效前后缀表达式之间的转换。可以推测，存在算法实现将无论多复杂的表达式正确转化。

首先学习的一个技术是使用后文将深入讨论的全括号表达式记法。A+B*C可以写作(A+(B*C))来显式地指出乘法比加法优先级更高。然而进一步观察后，可以发现每对括号也标记了一对操作对象的开头和结尾，并且对应的操作符位于中间。

观察子表达式（B*C）的右侧括号。如果能够将乘法符号移动到那个位置，并且将左侧对应的括号去掉，获得BC*，实际上便完成了子表达式转化为后缀表达式。若再将加号操作符移到右侧括号的位置，并再次去掉对应的左侧括号，便将整个表达式都实现了向后缀表达式的转换。（如图6所示）

![../_images/moveright.png](http://interactivepython.org/courselib/static/pythonds/_images/moveright.png)

如果进行相同的操作，但是取而代之地，将操作符移往左边括号，那么便得到了前缀记法（如图7所示）。括号对的位置实际上给出了闭合操作符的最终位置。

![../_images/moveleft.png](http://interactivepython.org/courselib/static/pythonds/_images/moveleft.png)

因此为了实现表达式的转换，无论多么复杂，无论是转为前缀或者后缀记法，都要按照操作的顺序来实现全括号化。操作符的左移或右移取决于目标是前缀或者后缀记法。

以下是一个更复杂的表达式：（A + B）\*（C）-（D - E）\*(F + G)。图8演示了其转为前缀或者后缀记法。

![../_images/complexmove.png](http://interactivepython.org/courselib/static/pythonds/_images/complexmove.png)

### 3.9.2 一般中缀转后缀 ###

为建立中缀表达式转为后缀表达式的算法，需要先仔细研究一下转化过程。

再次考虑表达式A+B\*C。如前文所述，ABC\*+是等效的后缀记法。读者应当已经注意到，操作对象A，B，C 的相对位置没有发生改变，仅有操作符发生了改变。再看看中缀表达式中的操作符。从左到右依次出现的第一个操作符是+。然而，在其后缀表达式中，+被放在了末尾，因为第二个操作符*的优先级比它高。在最终的后缀表达式中，原表达式中的操作符的顺序被反了过来。

在处理表达式的时候，操作符必须储存在某个地方因为它们对应的右侧操作对象还没有出现。并且，这些被储存起来的操作符也许需要逆序，因为它们的优先级不同。本例中的加法和乘法便是这样。因为加法操作符在乘法操作符之前出现了而且优先级更低，因此它要在乘法操作符之后再出现。因为这个顺序的逆，便可以使用栈来保存操作符，直到它们被使用。

那（A + B）\* C 呢？A B + C \*是其等效前缀记法。同样地，从左至右处理中缀表达式，首先遇到的是+。在这种情况下，+ 已经放在了结果表达式中，因为有括号的存在，它的优先级高于乘法了。现在开始想想转换算法是如何运行的。当看到左侧的括号时，将其储存起来，因为即将有一个具有高优先级的操作符出现。该操作符必须等到对应的右侧括号出现时才能确定其位置（全括号化）。当右侧括号消失的时候，操作符便可以从栈里面取出。

当从左到右遍历该中缀表达式时，使用栈来储存操作符。这与第一个例子相反。栈的顶部始终是最新加入的操作符。当读取到一个新的操作符时，必须考虑其与栈中已有的操作符的优先级孰高孰低。

假设中缀表达式是由空格隔开的符号字符串。操作符为*, /, +, -, 并伴随有左括号和右括号。操作对象记号是单字母识别符 A, B, C, 等等。下面的步骤会按后缀记法生成符号的字符串。

1. 创建一个空栈称为opstack用来保存操作符。创建一个空列表用于保存输出。
2. 

